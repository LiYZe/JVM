# 类加载机制

将Class文件转换为能被使用的java类型。

# 类加载时机

整个生命周期将会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段。

## 初始化

“加载”阶段自由把握，一下六种情况必须初始化

1.new、getstatic、putstatic或invokestatic这四条字节码指令

2.java.lang.reflect包的方法对类型进行反射调用

3.父类未初始化，先初始化父类

4.虚拟机启动时，优先初始化包含main方法类

5.当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。

6.定义JDK8中被default关键字修饰的接口方法

# 类加载过程

## 加载

1.通过类的全限定名来获取定义此类的二进制字节流。
2.将字节流的静态存储结构转化为方法区的运行时数据结构
3.内存生成类的java.langClass对象。

### 数组

 从内存中动态构造。
 
 ## 验证
 
 确保Class文件的字节流信息符合约束要求
 
 四个阶段分为：
 
 文件格式验证： 验证字节流是否符合lass文件格式规范
 
 元数据验证：对字节码所描述信息进行分析，保证符合要求
 
 字节码验证：通过数据流分析和控制流分析，确定程序语义合法、符合逻辑
 
 符号引用验证：确定该类是否缺少或被禁止访问所依赖的外部资源
 
 ## 准备
 
 为静态变量等类变量设置初始值
 
 ## 解析
 
 将符号引用转变为直接引用。只对17操作符号引用的字节码指令进行解析
 
 分为：类或接口解析、字段解析、方法解析、接口方法解析
 
 ## 初始化
 
 类中包含静态语句块或者有对变量赋值的操作，执行类构造器<clinit>()方法
  
# 类加载器

在虚拟机外实现通过类的全限定名获取类的二进制字节流
 
## 类与类加载器

两个类比较是否相等，必须在同一个类加载器下比较。如果加载它们的类加载器不同，则两个类一定不相等。

##  双亲委派模型

<div align="center"><img src="https://user-images.githubusercontent.com/37955886/116516205-e65e5200-a8ff-11eb-9553-271c96be42ca.png"/></div> 

各种类加载器之间的关系称为“双亲委派模型”。

类加载器之间的父子关系一般以组合关系复用父类加载器的代码。

每一个类加载器收到了类加载的请求，都会先把这个请求交给父类加载去完成，父类无法完成时，子加载器才会自己尝试完成。

### 启动类加载器

加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，能够被虚拟机识别的类库。

### 扩展类加载器

加载加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。

### 应用程序类加载器

加载用户类路径上所有的类库。

# 模块化系统

为了实现可配置的封装隔离机制

## 模块下的类加载器

扩展类加载器被平台类加载器取代。

<div align="center"><img src="https://user-images.githubusercontent.com/37955886/116518380-bebcb900-a902-11eb-98b4-a2f25e44ce2b.png"/></div> 





















 
 
 
 
 
 
 
 
 
