# 字节码执行引擎

分类：解释执行、编译执行

# 运行时帧栈

“方法”是虚拟机最基本的执行单元。

“帧栈”是虚拟机进行方法调用和执行的数据结构，也是运行时数据区中的虚拟机栈的栈元素。

包含：局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。

帧栈所需内存仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。

## 局部变量表

存放方法参数和方法内部定义的局部变量。

单位：变量槽，可以存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据

使用索引定位的方式使用局部变量表。

## 操作数栈

后入先出的栈。用于存放字节码指令

## 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数，符号引用一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。

## 方法返回地址

退出方法：

1.正常调用完成：执行引擎遇到任意一个方法返回的字节码指令。

2.异常调用完成：方法执行过程中遇到异常，且并未妥善处理

方法返回地址用于方法退出之后返回最初被调用的位置。

# 方法调用

确定被调用方法的版本

## 解析

调用目标在程序代码完成、编译器编译的那一刻就已确定，这类方法调用被称为“解析”。

5条方法调用字节码指令，分别是：

invokestatic：用于调用静态方法。

invokespecial：用于调用实例构造器<init>()方法、私有方法和父类中的方法。

invokevirtual：用于调用所有的虚方法（无法在类加载的时候把符号引用解析为该方法的直接饮用）。

invokeinterface：用于调用接口方法，会在运行时再确定一个实现该接口的对象。

## 分派

与多态相关。

### 静态分派

与重载相关。（传参）

![image](https://user-images.githubusercontent.com/37955886/116522159-705de900-a907-11eb-902c-c24999d039da.png)

“Human”被称为“静态类型”，或者叫“外观类型”。
“Man”则被称为变量的“实际类型”，或者叫“运行时类型”

虚拟机（或者准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。

如果有多个静态类型，会选择合适的类型。

自动转换会根据char>int>long>float>double的顺序转型进行匹配，但不会匹配到byte和short类型的重载。随后会自动装箱，紧接着装换为它实现的接口或父类。优先级最低的为可见变长参数的重载。

### 动态分派

与重写相关。

在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。

invokevirtual指令根据方法接收者（要执行方法的所有者）的实际类型来选择方法版本。

只对方法有效，对字段无效。字段永远不参与多态，只会执行当前类的字段。


### 单分派与多分派

方法的接收者与方法的参数统称为方法的宗量。

根据分派基于多少种宗量，可分为单分派与多分派。

单分派：根据一个宗量对目标方法进行选择。

多分派：根据多于一个宗量对目标方法进行选择。

Java语言的静态分派属于多分派类型。

Java语言的动态分派属于单分派类型。

### 实现

方法区中简历虚方法表，以代替元数据查找。

# 动态类型语言支持

动态类型语言：它的类型检查的主体过程是在运行期而不是编译期进行的，也就是输入代码之后所进行的执行代码。

# 基于栈的字节码解释执行引擎

## 解释执行

![image](https://user-images.githubusercontent.com/37955886/116529245-51635500-a90f-11eb-8b78-b721276f5178.png)

## 基于栈的指令集与基于寄存器的指令集 

栈：指令压栈出栈
寄存器：改变寄存器的值


























