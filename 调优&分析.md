# 调优&分析

# 工具

## jps

列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID。

## jstat

用于监视虚拟机各种运行状态信息的命令行工具。

## jinfo

实时查看和调整虚拟机各项参数。

## jmap

用于生成堆转储快照（一般称为heapdump或dump文件），还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。

## jhat

与jmap搭配使用，来分析jmap生成的堆转储快照。

### 缺点

1.般不会在部署应用程序的服务器上直接分析堆转储快照。

2.jhat的分析功能相对来说比较简陋

## jstack

用于生成虚拟机当前时刻的线程快照。

### 线程快照

当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因。

# 可视化故障处理工具

## JHSDB

基于服务性代理（Serviceability Agent，SA）实现的进程外调试工具。

## JConsole

基于JMX的可视化监视、管理工具。它的主要功能是通过JMX的MBean对系统进行信息收集和参数动态调整。

## VisualVM

功能最强大的运行监视和故障处理程序之一

### 优点

不需要被监视的程序基于特殊Agent去运行，因此它的通用性很强，对应用程序实际性能的影响也较小，使得它可以直接应用在生产环境中。

## Java Mission Control

作为Eclipse的插件来使用。JMC与虚拟机之间同样采取JMX协议进行通信，JMC一方面作为JMX控制台，显示来自虚拟机MBean提供的数据；另一方面作为JFR的分析工具，展示来自JFR的数据。

# HotSpot虚拟机插件及工具

## HSDIS

HotSpot虚拟机即时编译代码的反汇编插件，它包含在HotSpot虚拟机的源码当中。

HSDIS插件的作用是让HotSpot的-XX：+PrintAssembly指令调用它来把即时编译器动态生成的本地代码还原为汇编代码输出，同时还会自动产生大量非常有价值的注释，这样我们就可以通过输出的汇编代码来从最本质的角度分析问题。

# 大内存硬件上的程序部署策略

1.通过一个单独的Java虚拟机实例来管理大量的Java堆内存。

2.同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源。

同时使用若干个虚拟机建立逻辑集群来利用硬件资源。做法是在一台物理机器上启动多个应用服务器进程，为每个服务器进程分配不同端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。

## 控制Full GC

老年代的相对稳定，这主要取决于应用中大多数对象的生存时间不应当太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。

# 调优

<div align="center"><img src="https://user-images.githubusercontent.com/37955886/116800784-ba78e180-ab36-11eb-9d14-bb0c008f36ee.png"/></div> 

1.衡量系统现状。

2.根据用户所能接受的响应速度或者系统所拥有的机器已经所制成的用户量制定调优目标。

3.找出造成目前系统性能不足的最大瓶颈，实用工具找出造成瓶颈的代码。

4.分析需求，结合优化技巧制定优化策略，进行优化部署。

5.优化部署后，衡量系统状况判断是否达标。

## JVM调优

主要是内存管理方面调优。

### 避免新生代设置过小

会导致：

1.minor GC的次数更加频繁；

2.导致minor GC对象直接进入老年代，有可能触发Full GC；

### 避免新生代设置过大

导致：

1.老年代变小，导致Full GC更加频繁；

2.minor GC的耗时大幅增加；

### 避免Survivor区过小或者过大

在无法调整VM Heap以及新生代的大小时，调整Survivor区的大小也可。

### 合理设置新生代存活周期

存活周期决定了新生代经过多少次Minor GC后进入老年代。

## 程序调优

### CPU消耗严重

#### us高

原因：执行线程无任何挂起，且一直执行，造成线程饿死。

解决：对线程动作增加Thread.sleep，以释放PCU的执行权，降低CPU消耗。

#### sy高

原因：线程的远行状态经常切换/线程之间锁竞争激烈，造成线程状态要经常切换。

解决：减少线程

#### 文件IO消耗严重

原因：多个线程在写大量的数据到同一文件，导致文件快速变大，写入速度变慢，各个线程抢文件锁

解决：异步写文件；或批量读写；或限流；或限制文件大小

#### 网络IO消耗严重

原因：同时需要发送或者接收的包太多。

解决：限流，限制发送packet的频率。

#### 内存消耗严重

原因：消耗过多的JVM heap内存，造成GC频繁执行。

解决：释放不必要的引用；或使用对象缓存池；或采用合理的缓存失效算法；或合理使用SoftReference和WeakReference

#### 资源消耗不多，但程序慢

原因：锁竞争激烈

解决：使用并发包中的类；或使用Treiber算法；使用Micheal-Scott非阻塞队列算法；或少用锁；或拆分锁；或去除读写操作的互斥锁

#### 未充分使用硬件资源

未充分使用CPU：能并行处理的场景中未使用足够的线程；
未充分使用内存。

# 寻找性能瓶颈

通常表现为资源消耗过多、外部处理系统的性能不足，或者响应速度读达不到要求。

1.分析资源的消耗

2.结合Java工具找出造成资源消耗过多的代码

Linux中，可通过top或pidstat方式查看进程中线程的CPU的消耗状况。

## CPU消耗

中断>n内核>用户进程

### 上下文切换

存储目前线程的执行状态，并恢复要执行的线程的状态，这个过程称为上下文切换。

### 运行队列

系统的load主要由CPU的运行队列决定。

### 利用率

CPU在用户进程、内核、中断处理、IO等待以及空闲五个部分使用的百分比。

### 主要体现

#### us

us高，表示运行的应用消耗了大部分的CPU。

#### sy

sy高，百世Linux花费了更多的时间在进行线程切换，主要原因是启动的线程较多，且线程多数处于不断地阻塞和执行状态的变化过程，产生了大量的上下文切换。

#### hi

硬件中断造成。

## 文件IO消耗分析

主要通过pidstat查找和跟踪线程的文件IO消耗。

造成文件IO消耗严重的主要原因是多个线程需要大量的内容写入动作；或磁盘设备本身处理速度较慢；或文件系统较慢；或操作的文件本身过大

## 网络IO消耗分析

使用sar分析网络IO的消耗状况。

Java实现网络通信时，通常需要将对象序列化为字节流，进行发送，或读取字节流，并反序列化为对象，这一过程需消耗JVM堆内存，但JVM堆的内存大小通常有限，所以java应用一般不会造成网络IO消耗严重。

## 内存消耗分析

JVM内存消耗过多会导致GC执行频繁，CPU消耗增加，应用线程的执行速度严重下降，甚至造成OutOfMemoryError，最终导致Java程序退出。

可通过vmstat、sar、头皮、pidstat等方式查看swap和物理内存的消耗情况。

## 程序执行慢的原因

1.锁竞争激烈
2.未充分使用硬件资源
3.数据量增长

























